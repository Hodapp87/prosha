use crate::openmesh::{OpenMesh, Mat4};
use crate::prim;

// TODO: Do I benefit with Rc<Rule> below so Rule can be shared?
pub enum Rule {
    // Produce geometry, and possibly recurse further:
    Recurse(fn () -> RuleStep),
    // Stop recursing here:
    EmptyRule,
}
// TODO: Rename rules?
// TODO: It may be possible to have just a 'static' rule that requires
// no function call.

pub struct RuleStep {
    // The geometry generated by this rule on its own (not by any of
    // the child rules).
    pub geom: OpenMesh,

    // The "final" geometry, used only if recursion must be stopped.
    // This should be in the same coordinate space as 'geom', and
    // properly close any exit groups that it may have (and have no
    // exit groups of its own).
    pub final_geom: OpenMesh,

    // Child rules, paired with the transform that will be applied to
    // all of their geometry and parent vertex mappings
    pub children: Vec<(Rule, Mat4, Vec<usize>)>,
    // TODO: Clean this up, perhaps change the tuple to something
    // saner.
    // TODO: Also, document & rename this more clearly.
}

impl Rule {

    // TODO: Do I want to make 'geom' shared somehow, maybe with Rc? I
    // could end up having a lot of identical geometry that need not be
    // duplicated until it is transformed into the global space.
    //
    // This might produce bigger gains if I rewrite rule_to_mesh so that
    // rather than repeatedly transforming meshes, it stacks
    // transformations and then applies them all at once.

    pub fn to_mesh(&self, iters_left: u32) -> (OpenMesh, u32) {

        let mut nodes: u32 = 1;

        if iters_left <= 0 {
            match self {
                Rule::Recurse(f) => {
                    let rs: RuleStep = f();
                    return (rs.final_geom, 1);
                }
                Rule::EmptyRule => {
                    return (prim::empty_mesh(), nodes);
                }
            }
        }

        match self {
            Rule::Recurse(f) => {
                let rs: RuleStep = f();
                // TODO: This logic is more or less right, but it
                // could perhaps use some un-tupling or something.

                let subgeom: Vec<(OpenMesh, &Vec<usize>)> = rs.children.iter().map(
                    |(subrule, subxform, vmap)| {
                        // Get sub-geometry (still un-transformed):
                        let (submesh,n) = subrule.to_mesh(iters_left - 1);
                        // Tally up node count:
                        nodes += n;
                        
                        let m2 = submesh.transform(*subxform);
                        
                        (m2, vmap)
                    }).collect();
                
                // Connect geometry from this rule (not child rules):
                return (rs.geom.connect(&subgeom), nodes);
            }
            Rule::EmptyRule => {
                return (prim::empty_mesh(), nodes);
            }
        }
    }
}
